
# SQL

SQL, an acronym for Structured Query Language, is a specialized programming language designed for managing relational databases. 
Its functionalities span various tasks such as querying and updating data, defining and modifying database structures, and controlling access permissions within databases.

This language serves as a standard across numerous Relational Database Management Systems (RDBMS), including MySQL, PostgreSQL, SQL Server, Oracle, SQLite, and others. 
Although individual RDBMS may introduce specific dialects or extensions, SQL's core syntax and principles remain consistent across platforms.
SQL operates through a range of commands, categorized into four main types:
1. **Data Query Language (DQL):** Primarily used for retrieving data from databases. The pivotal command in DQL is SELECT, enabling users to specify desired columns and apply filtering conditions to refine results.
2. **Data Definition Language (DDL):** Focused on defining and modifying database structures. DDL commands like CREATE, ALTER, DROP, and TRUNCATE facilitate the creation, alteration, deletion, and truncation of tables and other database objects.
3. **Data Manipulation Language (DML):** Geared towards manipulating data within databases. Commands such as INSERT, UPDATE, and DELETE add, modify, and remove rows of data in database tables.
4. **Data Control Language (DCL):** Dedicated to managing access to data and database functionalities. DCL commands like GRANT and REVOKE empower users to grant and revoke privileges and permissions to database objects.

In SQL, clauses serve as integral components of statements, allowing users to specify conditions, filters, and constraints to manipulate or retrieve data efficiently. Here are some commonly used clauses in SQL:
- **SELECT Clause:** Specifies columns to retrieve from one or more tables.
- **FROM Clause:** Identifies the table(s) from which to retrieve data.
- **WHERE Clause:** Filters rows based on specified conditions.
- **GROUP BY Clause:** Groups rows sharing identical values, often used with aggregate functions.
- **HAVING Clause:** Filters groups generated by the GROUP BY clause based on specified conditions.
- **ORDER BY Clause:** Sorts the result set by specified columns.
- **LIMIT (or TOP) Clause:** Restricts the number of rows returned by a query.
- **OFFSET (or OFFSET FETCH NEXT) Clause:** Skips a specified number of rows before returning query results.
- **DISTINCT Clause:** Eliminates duplicate rows, returning unique values from the result set.

### Constraints in SQL

These are rules that define certain limitations or conditions on the data that can be stored in a table. These constraints ensure data integrity, enforce business rules, and maintain consistency within the database. Here's an overview of common constraints in SQL:
1. **Primary Key Constraint:** A primary key constraint uniquely identifies each record in a table. It ensures that the values in the specified column(s) are unique and not null.
   ```sql
   CREATE TABLE students (student_id INT PRIMARY KEY, name VARCHAR (50));
   ```
2. **Foreign Key Constraint:** A foreign key constraint establishes a relationship between two tables. It ensures referential integrity by enforcing those values in a column (or set of columns) of one table match values in another table's primary key.
   ```sql
   CREATE TABLE orders (order_id INT PRIMARY KEY, customer_id INT, 
                        FOREIGN KEY (customer_id) REFERENCES customers(customer_id));
   ```
3. **Unique Constraint:** A unique constraint ensures that all values in the specified column(s) are unique. Unlike primary key constraints, unique constraints allow null values.
   ```sql
   CREATE TABLE employees (employee_id INT UNIQUE, email VARCHAR (50) UNIQUE);
   ```
4. **Check Constraint:** A check constraint enforces a condition on the values allowed in a column. It validates the data before it is inserted or updated in the table.
   ```sql
   CREATE TABLE products (product_id INT, price DECIMAL (10,2), CONSTRAINT chk_price CHECK (price > 0));
   ```
5. **Not Null Constraint:** A not null constraint ensures that a column does not contain null values. It requires a value to be specified for the column when inserting or updating records.
   ```sql
   CREATE TABLE employees (employee_id INT PRIMARY KEY, name VARCHAR(50) NOT NULL);
   ```
6. **Default Constraint:** A default constraint assigns a default value to a column when no value is explicitly provided during an insert operation. It ensures that the column always has a value, even if one is not provided.
   ```sql
   CREATE TABLE students (student_id INT PRIMARY KEY, name VARCHAR(50), grade CHAR(1) DEFAULT 'A');
   ```

### Aggregate Functions

Aggregate functions in SQL are used to perform calculations on multiple rows of a single column of a table and return a single value. They are often used with the GROUP BY clause of the SELECT statement.

#### Common Aggregate Functions
1. **MIN()** - Returns the minimum value from the selected column.
   ```sql
   SELECT MIN(Salary) AS MinSalary FROM Salaries;
   ```
2. **MAX()** - Returns the max value from the selected column.
   ```sql
   SELECT MAX(Salary) AS MaxSalary FROM Salaries;
   ```
3. **SUM()** - Returns the total sum of a numerical column.
   ```sql
   SELECT SUM(Salary) AS TotalSalaries FROM Salaries;
   ```
4. **AVG()** - Returns the average value of a numerical column.
   ```sql
   SELECT AVG(Salary) AS AverageSalary FROM Salaries;
   ```
5. **COUNT()** - Returns the number of rows in a set.
   ```sql
   SELECT COUNT(*) AS TotalEmployees FROM Employees;
   ```

#### Using Aggregate Functions with GROUP BY
Aggregate functions are often used with the GROUP BY clause to group rows that have the same values in specified columns.
```sql
SELECT DepartmentID, COUNT(*) AS TotalEmployees, AVG(Salary) AS AverageSalary 
FROM Employees GROUP BY DepartmentID;
```

#### Handling NULL Values in Aggregate Functions
- **COUNT(column):** Counts non-NULL values.
- **SUM(column), AVG(column), MIN(column), MAX(column):** Ignore NULL values in the calculation.

Example:
```sql
SELECT COUNT(Salary) AS NonNullSalaries FROM Employees;
```

#### Combining Aggregate Functions with HAVING
The HAVING clause is used to filter groups based on the result of aggregate functions.
```sql
SELECT DepartmentID, COUNT(*) AS TotalEmployees FROM Employees 
GROUP BY DepartmentID HAVING COUNT(*) > 5;
```

### Joins

A join is an SQL operation that combines data from two or more tables based on a related column between them. Joins are used to retrieve data that is spread across multiple tables.

#### Types of Joins
1. **Inner Join:** Returns the records that have matching columns in both tables based on the given condition.
   ```sql
   SELECT Employees.FirstName, Employees.LastName, Departments.DepartmentName 
   FROM Employees 
   INNER JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
   ```
2. **Left Join:** Returns all records from the left table and the matched records from the right table. If no match is found, the result includes NULLs for columns from the right table.
   ```sql
   SELECT Employees.FirstName, Employees.LastName, Departments.DepartmentName 
   FROM Employees 
   LEFT JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
   ```
3. **Right Join:** Returns all records from the right table and the matched records from the left table. If no match is found, NULL values are returned for columns from the left table.
   ```sql
   SELECT Employees.FirstName, Employees.LastName, Departments.DepartmentName 
   FROM Employees 
   RIGHT JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
   ```
4. **Full Join:** Returns all records when there is a match in either the left or right table. Rows from both tables are included, with NULLs in place where there is no match.
   ```sql
   SELECT Employees.FirstName, Employees.LastName, Departments.DepartmentName 
   FROM Employees 
   LEFT JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID 
   UNION 
   SELECT Employees.FirstName, Employees.LastName, Departments.DepartmentName 
   FROM Employees 
   RIGHT JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
   ```

### Indexing

Indexing in SQL is a technique used to optimize the performance of database queries by minimizing the number of disk accesses required when a query is processed. An index is a database object that improves the speed of data retrieval operations on a table at the cost of additional space and write performance overhead.

#### Why and When to Use Indexing?
In a database, data is stored on disk in data pages. Each page typically contains multiple rows of a table. When a query is executed, the database needs to read these pages from disk into memory to process the query.

- **Without Indexing:**
  Consider a table with a million rows and a query that searches for a specific record by a non-indexed column, for example, finding an employee by their last name. Without an index, the database performs a full table scan:
  - **Full Table Scan:** The database reads each data page sequentially and examines every row to find matches.
  - **Disk Accesses:** This process can involve reading hundreds or thousands of pages from a disk, resulting in numerous disk I/O operations.

- **With Indexing:**
  Indexes improve this by providing a data structure that allows the database to quickly locate the rows that satisfy the query conditions:
  - **Index Structure:** When an index is created on a column (e.g., LastName), the database builds a data structure (usually a B-tree or a hash table) that maintains pointers to the actual data rows.
  - **Efficient Search:** Instead of scanning the entire table, the database uses the index to quickly navigate to the relevant pages.
  - **Reduced Disk Accesses:** By accessing a small portion of the index, the database can directly locate the data pages containing the matching rows, minimizing the number of disk reads.


### How do we do Indexing?
To create an index, you use the CREATE INDEX statement followed by the index name, the table name, and the column(s) to be indexed.
```sql
CREATE INDEX idx_employee_department ON Employees (DepartmentID);
CREATE INDEX idx_salary_employee ON Salaries (EmployeeID);
```

#### Types of Indexes:
1. **Primary Index:** Automatically created on the primary key of the table.
   ```sql
   CREATE TABLE Employees (EmployeeID int PRIMARY KEY, 
       FirstName varchar(50), LastName varchar(50), HireDate date);
   ```
2. **Unique Index:** Ensures that the values in the indexed column(s) are unique.      
   ```sql
   CREATE UNIQUE INDEX IX_Employees_Email ON Employees (Email);
   ```
3. **Non-Unique Index:** Created to improve the performance of queries but does not enforce uniqueness.
   ```sql
   CREATE INDEX IX_Employees_LastName ON Employees (LastName);
   ```
4. **Composite Index:** An index on multiple columns.
   ```sql
   CREATE INDEX IX_Employees_FirstName_LastName ON Employees (FirstName, LastName);
   ```
5. **Clustered Index:** Determines the physical order of data in the table, typically only one per table.
   ```sql
   CREATE CLUSTERED INDEX IX_Employees_HireDate ON Employees (HireDate);
   ```
6. **Non-Clustered Index:** Does not alter the physical order of the table; a table can have multiple non-clustered indexes.
   ```sql
   CREATE NONCLUSTERED INDEX IX_Employees_LastName ON Employees (LastName);
   ```

#### Benefits of Indexing
- **Speed:** Queries run significantly faster because fewer pages need to be read from disk.
- **Efficiency:** Reduces CPU and memory usage because fewer data pages are processed.
- **Scalability:** Allows handling larger datasets efficiently.

#### Drawbacks of Indexing
- **Space Overhead:** Indexes consume additional disk space.
- **Maintenance Overhead:** Insert, update, and delete operations are slower because the indexes must be updated accordingly.
- **Write Performance:** More indexes mean more work for the database when modifying data.

### Partitioning

Partitioning in SQL refers to the process of dividing a large database table into smaller, more manageable pieces, facilitating easier handling and manipulation of the data.

#### Why Partition? 
Partitioning is primarily used for improving query performance and manageability of large tables. It allows you to access and manipulate smaller subsets of data more efficiently.

#### Types of Partitioning:
1. **Range Partitioning:** Data is partitioned based on a specified range of values. 
   For example, you might partition a sales table by date, with each partition representing a specific range of dates (e.g., monthly or yearly partitions).
   ```sql
   CREATE TABLE Employees (
       EmployeeID int,
       FirstName varchar(50),
       LastName varchar(50),
       DepartmentID int,
       HireDate date,
       Email varchar(50),
       PRIMARY KEY (EmployeeID, HireDate)
   )
   PARTITION BY RANGE (YEAR(HireDate)) (
       PARTITION p0 VALUES LESS THAN (2017),
       PARTITION p1 VALUES LESS THAN (2018),
       PARTITION p2 VALUES LESS THAN (2019),
       PARTITION p3 VALUES LESS THAN (2020),
       PARTITION p4 VALUES LESS THAN (2021),
       PARTITION p5 VALUES LESS THAN MAXVALUE);
   ```
2. **List Partitioning:** Data is partitioned based on discrete values or ranges of values defined by the user. For instance, you might partition a customer table by country, with each partition representing customers from a specific country.
   ```sql
   CREATE TABLE Employees (
       EmployeeID int,
       FirstName varchar(50),
       LastName varchar(50),
       DepartmentID int,
       HireDate date,
       Email varchar(50),
       PRIMARY KEY (EmployeeID, HireDate)
   )
   PARTITION BY RANGE (YEAR(HireDate)) (
       PARTITION p0 VALUES LESS THAN (2017),
       PARTITION p1 VALUES LESS THAN (2018),
       PARTITION p2 VALUES LESS THAN (2019),
       PARTITION p3 VALUES LESS THAN (2020),
       PARTITION p4 VALUES LESS THAN (2021),
       PARTITION p5 VALUES LESS THAN MAXVALUE);
   ```
3. **Hash Partitioning:** Data is distributed across partitions based on a hash function applied to one or more columns. This method is useful for evenly distributing data across partitions without any specific range or list criteria.
   ```sql
   CREATE TABLE Employees (
       EmployeeID int,
       FirstName varchar(50),
       LastName varchar(50),
       DepartmentID int,
       HireDate date,
       Email varchar(50),
       PRIMARY KEY (EmployeeID)
   )
   PARTITION BY HASH (EmployeeID) PARTITIONS 4;
   ```

   PARTITION BY HASH (EmployeeID) PARTITIONS 4;

4. **Composite Partitioning:** Combination of range, list, or hash partitioning methods on different columns to achieve more granular partitioning strategies.
5. **Sub-Partitioning:** Sub-partitioning is the process where each partition is further divided into smaller partitions. This hierarchical partitioning structure allows for even finer data organization and management. 
   For example, if you have a partitioned table based on date ranges, you could further sub-partition each date range by another attribute such as region or product category.

6. **Interval Partitioning:** It is a feature available in some SQL database systems that automatically creates partitions based on a specified interval, such as a range of dates or numeric values. 
   This eliminates the need for manually defining partitions for each specific value range. For instance, you can create a table partitioned by month, and the database system automatically creates new partitions as new data is inserted, based on the defined interval (e.g., each month).

7. **System Partitioning:** It is a partitioning strategy where the database system manages the allocation of data to partitions based on predefined rules or algorithms. System partitioning can offer benefits such as automatic load balancing and optimized data distribution across partitions.

### Managing Partitions
- **Adding Partitions:** You can add new partitions to accommodate additional data as needed.
- **Dropping Partitions:** Partitions that are no longer needed can be dropped to free up storage space.
- **Splitting and Merging Partitions:** In some databases, you can split or merge partitions to adjust the partitioning scheme according to changing requirements.
